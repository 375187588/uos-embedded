/*
 * uos-conf.h
 *  Created on: 06.10.2015
 *      Author: a_lityagin <alexraynepe196@gmail.com>
 *                         <alexraynepe196@hotbox.ru>
 *                         <alexraynepe196@mail.ru>
 *                         <alexrainpe196@hotbox.ru>
 *  
 *  *\~russian UTF8
 *  это дефолтовый конфигурационный файл уОС. здесь сведены настройки модулей.
 *  для сборки своей оси, скопируйте этот файл в папку своего проекта и 
 *      переопределите настройки.
 */

#ifndef UOS_CONF_H_
#define UOS_CONF_H_

/**************************************************************************
 *                              runtime
 ************************************************************************** */
/* UOS_FOR_SPEED выбирает более скоростной код против более компактного
 *  1   - выбирает оптимизации серьезные
 *  2   - включает оптимизации предельные
 * */
#define UOS_FOR_SPEED   2

/* UOS_FOR_SPEED выбирает даже незначительно компактный код против более скоростного
 * */
#define UOS_FOR_SIZE    0

/**************************************************************************
 *                              uos.h
 ************************************************************************** */
/**\~russian
 * FASTER_LOCKS добавляет код ускоряющий захват уже захваченого мутекса
 *  = 0 - всякий захват требует выхода в защищенный от шедулера режим 
 *  = 1 - если текущая задача уже захватила мутекс, все выполняется бустрее.
 *      но чуть разбухает размер кода
 * */
//#define FASTER_LOCKS

/* по умолчанияю захват/ожидание мутеха реализуется через универсальные процедуры
 * mutex_lock/wait_until (mutex_t *m, scheduless_condition waitfor, void* waitarg) 
 * UOS_MUTEX_FASTER редуцирует код mutex_lock в собственные версии процедур, чуть более 
 *      быстрые, однако если в проекте используются mutex_ХХХ_until - то это добавит лишний код
 * */
//#define UOS_MUTEX_FASTER

/* по умолчанияю сигнал мутеху приводит к переключению на активированые задачи 
 *  если они более приоритетны
 * UOS_SIGNAL_SMART подключает проверку блокировки активированой нитки другим мутехом, 
 *  чтобы не делать лишнего переключения. эта проверка требует использовать дополнительное
 *     описание состояния нитки, и реализовано за счет ухудшения безопасности
 * */
#define UOS_SIGNAL_SMART_SAFE  1
#define UOS_SIGNAL_SMART_SMALL 2
#define UOS_SIGNAL_SMART UOS_SIGNAL_SMART_SMALL

/**\~russian
 * RECURSIVE_LOCKS задает стиль мутекса
 *  = 0 - ближайший unlock освобождает мутекс
 *  = 1 - мутекс отслеживает количество блокировок в текущей задаче и 
 *          на каждый вызов lock должен быть произведен unlock  
 * */
//#undef RECURSIVE_LOCKS
//#define RECURSIVE_LOCKS 0

/**\~russian
 * INLINE задает модификатор для инлайн функций уОС.
 * */
//#ifndef INLINE
//#define INLINE inline
//#endif

#define DEBUG_UARTBAUD 921600

/* IDLE_TASK_STACKSZ - стек всякой задачи должен справляться исполнением прерывания
 * для ЭЛВИС использование USER_TIMERS добавит накладных на стек 
 * */
#define IDLE_TASK_STACKSZ   (256+512+MIPS_FSPACE)

/**************************************************************************
 *                              IRQ
 ************************************************************************** */
// это макро задает стиль вызова обработчика прерывания:
//  MIPS_FSPACE == 0 - обработчик вызывается как обычная процедура task_t* hanler()
//  MIPS_FSPACE >0 - прерывание само выделяет в стеке пространство MIPS_FSPACE и 
//                   переходит в обработчик в обход преамбул начала/конца - это чуть быстрее
//  ELVEES требует размер фрейма 88 - без оптимизации, иначе 40 

//#define MIPS_FSPACE 0

/**************************************************************************
 *                              timer.h
 ************************************************************************** */

/**\~russian
 * макро SW_TIMER отключает инициализацию обработчика прерывания системного таймера. в этом случае настраивает и запускает таймер
 * пользовательский код. обновление таймера производится вызовом timer_update
 * */
//#define SW_TIMER 1

/**\~russian
 * макро USER_TIMERS включает функционал множественных пользовательских таймеров на общем системном таймере.
 * см. функции user_timer_XXX
 * для ЭЛВИС использование USER_TIMERS добавит накладных на стек см. IDLE_TASK_STACKSZ 
 * */
//#define USER_TIMERS 1

/**\~russian
 * макро USEC_TIMER дает возможность использовать прецизионный таймер сразрешением в [us]. см. timer_init_us
 * */
//#define USEC_TIMER 1

/**\~russian
 * макро TIMER_NO_DAYS опускает реализацию _timer_t.days - экономит время обработчика прерывания
 *  используется модулями: smnp
 * */
//#define TIMER_NO_DAYS 1 

/**\~russian
 * макро TIMER_NO_DECISEC опускает реализацию _timer_t.decisec - экономит время обработчика прерывания
 *  , это поле требуется для протокола TCP!!! 
 * */
//#define TIMER_NO_DECISEC 1 



/**************************************************************************
 *                              time.h
 ************************************************************************** */
/**\~russian
 * UOS_LEAP_SECONDS включает функционал вычисления tz_time_t.sec в функции tz_time
 * */
//#define UOS_LEAP_SECONDS 1


/**************************************************************************
 *                              debug console
 ************************************************************************** */
/** \~russian
 * NDEBUG отключает дебажный вывод функций assert
 */
//#define NDEBUG

/** \~russian
 * NO_DEBUG_PRINT отключает дебажный вывод функций debug_XXX
 */
//#define NO_DEBUG_PRINT

/** \~russian
 * DEBUG_SIMULATE заглушает дебажный ввод/вывод функций debug_getchar
 */
//#define DEBUG_SIMULATE

//#define MEM_DEBUG 1

//* отключает возможность переключения задач при простое на порте отладки. важно для поведения
//  debug_getchar - конкуретный вариант не занимает время процессора, неконкурентный
//      блокируется на этом вызове.
//  нужно чтобы отвязать debug_XXX от менегера задач, на этом можно сэкономить код
#define DEBUG_IO_NOCONCURENCE

 /**************************************************************************
 *                              Task Hooks
 ************************************************************************** */
//#define UOS_ON_NEW_TASK(t)
//#define UOS_ON_DESTROY_TASK(t, message)

//#define UOS_WITH_NEWLIB
//!	Newlib port: см. posix/sys/newlib.h
//этот хук на переключение задач УОС, его надо назначить на uos-conf:UOS_ON_SWITCH_TOTASK(t) или
//	использовать в своем хуке
#ifdef UOS_WITH_NEWLIB
//	NewLib использует _impure_ptr для связи с контекстом нитки.
//	!!! позаботьтесь сами о том чтобы каждая нитка имела свой newlib-контест -  _reent,
//		задача этого хука - получать этот контекст в _impure_ptr
#define UOS_ON_SWITCH_TOTASK(t) newlib_on_task_switch(t)
#else
//#define UOS_ON_SWITCH_TOTASK(t) uos_on_task_switch(t)
#endif

//#define UOS_ON_TIMER(t)         uos_on_timer_hook(t)


/**\~russian
  * эти атрибуты используются для указания размещения кода линкеру для систем с отдельной памятью для прерываний
  *	и быстрого кода
*/
//#define CODE_FAST __attribute__((section(".text.hot")))
//#define CODE_ISR  __attribute__((section(".text.isr_used")))
//#define USED_ISR  __attribute__((section(".text.isr_used")))



#endif /* UOS_CONF_H_ */
